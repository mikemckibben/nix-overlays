// Code generated by counterfeiter. DO NOT EDIT.
package tracingfakes

import (
	"context"
	"sync"
	"time"

	"go.opentelemetry.io/otel/api/core"
	"go.opentelemetry.io/otel/api/trace"
	"google.golang.org/grpc/codes"
)

type FakeSpan struct {
	AddEventStub        func(context.Context, string, ...core.KeyValue)
	addEventMutex       sync.RWMutex
	addEventArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []core.KeyValue
	}
	AddEventWithTimestampStub        func(context.Context, time.Time, string, ...core.KeyValue)
	addEventWithTimestampMutex       sync.RWMutex
	addEventWithTimestampArgsForCall []struct {
		arg1 context.Context
		arg2 time.Time
		arg3 string
		arg4 []core.KeyValue
	}
	EndStub        func(...trace.EndOption)
	endMutex       sync.RWMutex
	endArgsForCall []struct {
		arg1 []trace.EndOption
	}
	IsRecordingStub        func() bool
	isRecordingMutex       sync.RWMutex
	isRecordingArgsForCall []struct {
	}
	isRecordingReturns struct {
		result1 bool
	}
	isRecordingReturnsOnCall map[int]struct {
		result1 bool
	}
	SetAttributesStub        func(...core.KeyValue)
	setAttributesMutex       sync.RWMutex
	setAttributesArgsForCall []struct {
		arg1 []core.KeyValue
	}
	SetNameStub        func(string)
	setNameMutex       sync.RWMutex
	setNameArgsForCall []struct {
		arg1 string
	}
	SetStatusStub        func(codes.Code)
	setStatusMutex       sync.RWMutex
	setStatusArgsForCall []struct {
		arg1 codes.Code
	}
	SpanContextStub        func() core.SpanContext
	spanContextMutex       sync.RWMutex
	spanContextArgsForCall []struct {
	}
	spanContextReturns struct {
		result1 core.SpanContext
	}
	spanContextReturnsOnCall map[int]struct {
		result1 core.SpanContext
	}
	TracerStub        func() trace.Tracer
	tracerMutex       sync.RWMutex
	tracerArgsForCall []struct {
	}
	tracerReturns struct {
		result1 trace.Tracer
	}
	tracerReturnsOnCall map[int]struct {
		result1 trace.Tracer
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSpan) AddEvent(arg1 context.Context, arg2 string, arg3 ...core.KeyValue) {
	fake.addEventMutex.Lock()
	fake.addEventArgsForCall = append(fake.addEventArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []core.KeyValue
	}{arg1, arg2, arg3})
	fake.recordInvocation("AddEvent", []interface{}{arg1, arg2, arg3})
	fake.addEventMutex.Unlock()
	if fake.AddEventStub != nil {
		fake.AddEventStub(arg1, arg2, arg3...)
	}
}

func (fake *FakeSpan) AddEventCallCount() int {
	fake.addEventMutex.RLock()
	defer fake.addEventMutex.RUnlock()
	return len(fake.addEventArgsForCall)
}

func (fake *FakeSpan) AddEventCalls(stub func(context.Context, string, ...core.KeyValue)) {
	fake.addEventMutex.Lock()
	defer fake.addEventMutex.Unlock()
	fake.AddEventStub = stub
}

func (fake *FakeSpan) AddEventArgsForCall(i int) (context.Context, string, []core.KeyValue) {
	fake.addEventMutex.RLock()
	defer fake.addEventMutex.RUnlock()
	argsForCall := fake.addEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSpan) AddEventWithTimestamp(arg1 context.Context, arg2 time.Time, arg3 string, arg4 ...core.KeyValue) {
	fake.addEventWithTimestampMutex.Lock()
	fake.addEventWithTimestampArgsForCall = append(fake.addEventWithTimestampArgsForCall, struct {
		arg1 context.Context
		arg2 time.Time
		arg3 string
		arg4 []core.KeyValue
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("AddEventWithTimestamp", []interface{}{arg1, arg2, arg3, arg4})
	fake.addEventWithTimestampMutex.Unlock()
	if fake.AddEventWithTimestampStub != nil {
		fake.AddEventWithTimestampStub(arg1, arg2, arg3, arg4...)
	}
}

func (fake *FakeSpan) AddEventWithTimestampCallCount() int {
	fake.addEventWithTimestampMutex.RLock()
	defer fake.addEventWithTimestampMutex.RUnlock()
	return len(fake.addEventWithTimestampArgsForCall)
}

func (fake *FakeSpan) AddEventWithTimestampCalls(stub func(context.Context, time.Time, string, ...core.KeyValue)) {
	fake.addEventWithTimestampMutex.Lock()
	defer fake.addEventWithTimestampMutex.Unlock()
	fake.AddEventWithTimestampStub = stub
}

func (fake *FakeSpan) AddEventWithTimestampArgsForCall(i int) (context.Context, time.Time, string, []core.KeyValue) {
	fake.addEventWithTimestampMutex.RLock()
	defer fake.addEventWithTimestampMutex.RUnlock()
	argsForCall := fake.addEventWithTimestampArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeSpan) End(arg1 ...trace.EndOption) {
	fake.endMutex.Lock()
	fake.endArgsForCall = append(fake.endArgsForCall, struct {
		arg1 []trace.EndOption
	}{arg1})
	fake.recordInvocation("End", []interface{}{arg1})
	fake.endMutex.Unlock()
	if fake.EndStub != nil {
		fake.EndStub(arg1...)
	}
}

func (fake *FakeSpan) EndCallCount() int {
	fake.endMutex.RLock()
	defer fake.endMutex.RUnlock()
	return len(fake.endArgsForCall)
}

func (fake *FakeSpan) EndCalls(stub func(...trace.EndOption)) {
	fake.endMutex.Lock()
	defer fake.endMutex.Unlock()
	fake.EndStub = stub
}

func (fake *FakeSpan) EndArgsForCall(i int) []trace.EndOption {
	fake.endMutex.RLock()
	defer fake.endMutex.RUnlock()
	argsForCall := fake.endArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSpan) IsRecording() bool {
	fake.isRecordingMutex.Lock()
	ret, specificReturn := fake.isRecordingReturnsOnCall[len(fake.isRecordingArgsForCall)]
	fake.isRecordingArgsForCall = append(fake.isRecordingArgsForCall, struct {
	}{})
	fake.recordInvocation("IsRecording", []interface{}{})
	fake.isRecordingMutex.Unlock()
	if fake.IsRecordingStub != nil {
		return fake.IsRecordingStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isRecordingReturns
	return fakeReturns.result1
}

func (fake *FakeSpan) IsRecordingCallCount() int {
	fake.isRecordingMutex.RLock()
	defer fake.isRecordingMutex.RUnlock()
	return len(fake.isRecordingArgsForCall)
}

func (fake *FakeSpan) IsRecordingCalls(stub func() bool) {
	fake.isRecordingMutex.Lock()
	defer fake.isRecordingMutex.Unlock()
	fake.IsRecordingStub = stub
}

func (fake *FakeSpan) IsRecordingReturns(result1 bool) {
	fake.isRecordingMutex.Lock()
	defer fake.isRecordingMutex.Unlock()
	fake.IsRecordingStub = nil
	fake.isRecordingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeSpan) IsRecordingReturnsOnCall(i int, result1 bool) {
	fake.isRecordingMutex.Lock()
	defer fake.isRecordingMutex.Unlock()
	fake.IsRecordingStub = nil
	if fake.isRecordingReturnsOnCall == nil {
		fake.isRecordingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isRecordingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeSpan) SetAttributes(arg1 ...core.KeyValue) {
	fake.setAttributesMutex.Lock()
	fake.setAttributesArgsForCall = append(fake.setAttributesArgsForCall, struct {
		arg1 []core.KeyValue
	}{arg1})
	fake.recordInvocation("SetAttributes", []interface{}{arg1})
	fake.setAttributesMutex.Unlock()
	if fake.SetAttributesStub != nil {
		fake.SetAttributesStub(arg1...)
	}
}

func (fake *FakeSpan) SetAttributesCallCount() int {
	fake.setAttributesMutex.RLock()
	defer fake.setAttributesMutex.RUnlock()
	return len(fake.setAttributesArgsForCall)
}

func (fake *FakeSpan) SetAttributesCalls(stub func(...core.KeyValue)) {
	fake.setAttributesMutex.Lock()
	defer fake.setAttributesMutex.Unlock()
	fake.SetAttributesStub = stub
}

func (fake *FakeSpan) SetAttributesArgsForCall(i int) []core.KeyValue {
	fake.setAttributesMutex.RLock()
	defer fake.setAttributesMutex.RUnlock()
	argsForCall := fake.setAttributesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSpan) SetName(arg1 string) {
	fake.setNameMutex.Lock()
	fake.setNameArgsForCall = append(fake.setNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetName", []interface{}{arg1})
	fake.setNameMutex.Unlock()
	if fake.SetNameStub != nil {
		fake.SetNameStub(arg1)
	}
}

func (fake *FakeSpan) SetNameCallCount() int {
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	return len(fake.setNameArgsForCall)
}

func (fake *FakeSpan) SetNameCalls(stub func(string)) {
	fake.setNameMutex.Lock()
	defer fake.setNameMutex.Unlock()
	fake.SetNameStub = stub
}

func (fake *FakeSpan) SetNameArgsForCall(i int) string {
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	argsForCall := fake.setNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSpan) SetStatus(arg1 codes.Code) {
	fake.setStatusMutex.Lock()
	fake.setStatusArgsForCall = append(fake.setStatusArgsForCall, struct {
		arg1 codes.Code
	}{arg1})
	fake.recordInvocation("SetStatus", []interface{}{arg1})
	fake.setStatusMutex.Unlock()
	if fake.SetStatusStub != nil {
		fake.SetStatusStub(arg1)
	}
}

func (fake *FakeSpan) SetStatusCallCount() int {
	fake.setStatusMutex.RLock()
	defer fake.setStatusMutex.RUnlock()
	return len(fake.setStatusArgsForCall)
}

func (fake *FakeSpan) SetStatusCalls(stub func(codes.Code)) {
	fake.setStatusMutex.Lock()
	defer fake.setStatusMutex.Unlock()
	fake.SetStatusStub = stub
}

func (fake *FakeSpan) SetStatusArgsForCall(i int) codes.Code {
	fake.setStatusMutex.RLock()
	defer fake.setStatusMutex.RUnlock()
	argsForCall := fake.setStatusArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSpan) SpanContext() core.SpanContext {
	fake.spanContextMutex.Lock()
	ret, specificReturn := fake.spanContextReturnsOnCall[len(fake.spanContextArgsForCall)]
	fake.spanContextArgsForCall = append(fake.spanContextArgsForCall, struct {
	}{})
	fake.recordInvocation("SpanContext", []interface{}{})
	fake.spanContextMutex.Unlock()
	if fake.SpanContextStub != nil {
		return fake.SpanContextStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.spanContextReturns
	return fakeReturns.result1
}

func (fake *FakeSpan) SpanContextCallCount() int {
	fake.spanContextMutex.RLock()
	defer fake.spanContextMutex.RUnlock()
	return len(fake.spanContextArgsForCall)
}

func (fake *FakeSpan) SpanContextCalls(stub func() core.SpanContext) {
	fake.spanContextMutex.Lock()
	defer fake.spanContextMutex.Unlock()
	fake.SpanContextStub = stub
}

func (fake *FakeSpan) SpanContextReturns(result1 core.SpanContext) {
	fake.spanContextMutex.Lock()
	defer fake.spanContextMutex.Unlock()
	fake.SpanContextStub = nil
	fake.spanContextReturns = struct {
		result1 core.SpanContext
	}{result1}
}

func (fake *FakeSpan) SpanContextReturnsOnCall(i int, result1 core.SpanContext) {
	fake.spanContextMutex.Lock()
	defer fake.spanContextMutex.Unlock()
	fake.SpanContextStub = nil
	if fake.spanContextReturnsOnCall == nil {
		fake.spanContextReturnsOnCall = make(map[int]struct {
			result1 core.SpanContext
		})
	}
	fake.spanContextReturnsOnCall[i] = struct {
		result1 core.SpanContext
	}{result1}
}

func (fake *FakeSpan) Tracer() trace.Tracer {
	fake.tracerMutex.Lock()
	ret, specificReturn := fake.tracerReturnsOnCall[len(fake.tracerArgsForCall)]
	fake.tracerArgsForCall = append(fake.tracerArgsForCall, struct {
	}{})
	fake.recordInvocation("Tracer", []interface{}{})
	fake.tracerMutex.Unlock()
	if fake.TracerStub != nil {
		return fake.TracerStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.tracerReturns
	return fakeReturns.result1
}

func (fake *FakeSpan) TracerCallCount() int {
	fake.tracerMutex.RLock()
	defer fake.tracerMutex.RUnlock()
	return len(fake.tracerArgsForCall)
}

func (fake *FakeSpan) TracerCalls(stub func() trace.Tracer) {
	fake.tracerMutex.Lock()
	defer fake.tracerMutex.Unlock()
	fake.TracerStub = stub
}

func (fake *FakeSpan) TracerReturns(result1 trace.Tracer) {
	fake.tracerMutex.Lock()
	defer fake.tracerMutex.Unlock()
	fake.TracerStub = nil
	fake.tracerReturns = struct {
		result1 trace.Tracer
	}{result1}
}

func (fake *FakeSpan) TracerReturnsOnCall(i int, result1 trace.Tracer) {
	fake.tracerMutex.Lock()
	defer fake.tracerMutex.Unlock()
	fake.TracerStub = nil
	if fake.tracerReturnsOnCall == nil {
		fake.tracerReturnsOnCall = make(map[int]struct {
			result1 trace.Tracer
		})
	}
	fake.tracerReturnsOnCall[i] = struct {
		result1 trace.Tracer
	}{result1}
}

func (fake *FakeSpan) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addEventMutex.RLock()
	defer fake.addEventMutex.RUnlock()
	fake.addEventWithTimestampMutex.RLock()
	defer fake.addEventWithTimestampMutex.RUnlock()
	fake.endMutex.RLock()
	defer fake.endMutex.RUnlock()
	fake.isRecordingMutex.RLock()
	defer fake.isRecordingMutex.RUnlock()
	fake.setAttributesMutex.RLock()
	defer fake.setAttributesMutex.RUnlock()
	fake.setNameMutex.RLock()
	defer fake.setNameMutex.RUnlock()
	fake.setStatusMutex.RLock()
	defer fake.setStatusMutex.RUnlock()
	fake.spanContextMutex.RLock()
	defer fake.spanContextMutex.RUnlock()
	fake.tracerMutex.RLock()
	defer fake.tracerMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSpan) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ trace.Span = new(FakeSpan)
